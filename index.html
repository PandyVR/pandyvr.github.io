<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Auto Shorts Generator — Proof of concept</title>
  <style>
    body{font-family:Inter,system-ui,Arial;margin:16px;background:#0f172a;color:#e6eef8}
    .card{background:#0b1220;padding:16px;border-radius:12px;margin-bottom:12px;box-shadow:0 6px 20px rgba(2,6,23,.6)}
    label{display:block;margin:8px 0 6px}
    input,button,select{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,.06);background:#071028;color:inherit}
    small{color:#9fb0d6}
    #log{white-space:pre-wrap;font-family:monospace;background:#041022;padding:12px;border-radius:8px;max-height:220px;overflow:auto}
  </style>
</head>
<body>
  <h1>Auto Shorts Generator — POC</h1>
  <div class="card">
    <strong>What this is</strong>
    <p>Drop a soundtrack + several clips. This POC detects beats (naive energy-peaks) and stitches trimmed clips to those beats using ffmpeg.wasm. It's meant as a starter template you can host on GitHub Pages.</p>
    <small>Important: browser-side FFmpeg is CPU+RAM heavy. Use short clips for testing.</small>
  </div>

  <div class="card">
    <label>1) Upload audio (song)</label>
    <input id="audioInput" type="file" accept="audio/*">

    <label>2) Upload clips (MP4, multiple)</label>
    <input id="videosInput" type="file" accept="video/*" multiple>

    <label>Output length (seconds)</label>
    <input id="outLen" type="number" value="15" min="5" max="60">

    <div style="margin-top:12px">
      <button id="generateAllBtn" disabled>Analyze & Generate Short</button>
    </div>
  </div>

  <div class="card">
    <label>Detected beat timestamps</label>
    <div id="beats">(no analysis yet)</div>
  </div>

  <div class="card">
    <label>Log / progress</label>
    <div id="log">idle</div>
  </div>

  <script type="module">
    import { createFFmpeg, fetchFile } from 'https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js';

    const logEl = document.getElementById('log');
    function log(...args){ logEl.textContent += '\\n' + args.join(' '); logEl.scrollTop = logEl.scrollHeight }

    const audioIn = document.getElementById('audioInput');
    const videosIn = document.getElementById('videosInput');
    const generateAllBtn = document.getElementById('generateAllBtn');
    const beatsEl = document.getElementById('beats');
    const outLenEl = document.getElementById('outLen');

    let audioFile = null;
    let videoFiles = [];
    let beats = [];

    // Enable generateAllBtn only if both audio and at least one clip loaded
    function updateGenerateBtnState() {
      generateAllBtn.disabled = !(audioFile && videoFiles.length > 0);
    }
    audioIn.addEventListener('change', e=>{
      audioFile = e.target.files[0];
      beatsEl.textContent = '(audio loaded, run generation)';
      updateGenerateBtnState();
    });
    videosIn.addEventListener('change', e=>{
      videoFiles = Array.from(e.target.files);
      log('loaded', videoFiles.length, 'clips');
      updateGenerateBtnState();
    });

    // --- naive beat detection using WebAudio energy peaks ---
    async function analyzeAudio(file){
      beatsEl.textContent = 'analyzing...';
      const arrBuf = await file.arrayBuffer();
      const ctx = new OfflineAudioContext(1, 44100 * 180, 44100); // up to 3 minutes safe
      const audioBuffer = await ctx.decodeAudioData(arrBuf);
      const data = audioBuffer.getChannelData(0);
      const sampleRate = audioBuffer.sampleRate;

      // frame energy
      const frameSize = Math.floor(sampleRate * 0.1); // 100ms
      const energies = [];
      for(let i=0;i<data.length;i+=frameSize){
        let s=0; for(let j=i;j<Math.min(i+frameSize,data.length);j++) s += data[j]*data[j];
        energies.push(s);
      }
      // smooth
      const smooth = energies.map((v,i)=>{ let sum=0, c=0; for(let j=i-2;j<=i+2;j++) if(energies[j]!=null){sum+=energies[j]; c++} return sum/c });
      // find peaks where energy > local mean * threshold
      const peaks = [];
      for(let i=2;i<smooth.length-2;i++){
        const localMean = (smooth[i-2]+smooth[i-1]+smooth[i]+smooth[i+1]+smooth[i+2])/5;
        if(smooth[i] > localMean * 1.8 && smooth[i] > smooth[i-1] && smooth[i] > smooth[i+1]){
          peaks.push(i * (frameSize / sampleRate));
        }
      }
      beats = peaks.slice(0, 20); // cap
      beatsEl.textContent = beats.length ? beats.map(b=>b.toFixed(2)+'s').join(', ') : '(no beats found)';
      log('detected', beats.length, 'peaks');
    }

    // --- FFmpeg wiring ---
    const ffmpeg = createFFmpeg({ log: true });
    let ffLoaded = false;

    async function ensureFF(){ 
      if(!ffLoaded){ 
        log('loading ffmpeg.wasm (this can take a while)...'); 
        await ffmpeg.load(); 
        ffLoaded=true; 
        log('ffmpeg ready'); 
      } 
    }

    // build a simple edit: for each beat, take next clip and trim to beat spacing
    async function generate(){
      if(!audioFile || videoFiles.length===0){ alert('need audio and clips'); return }
      await ensureFF();
      log('writing inputs to FS...');
      ffmpeg.FS('writeFile','song.mp3', await fetchFile(audioFile));
      // write video files
      for(let i=0;i<videoFiles.length;i++){
        const name = `clip${i}.mp4`;
        ffmpeg.FS('writeFile', name, await fetchFile(videoFiles[i]));
        log('wrote', name);
      }

      const targetLen = parseInt(outLenEl.value || '15');
      // pick beats that fit into targetLen
      let usableBeats = beats.filter(b=>b < targetLen);
      if(usableBeats.length===0){
        // fallback to evenly spaced times
        usableBeats = [];
        const step = targetLen / Math.min(videoFiles.length, 8);
        for(let i=0;i<Math.min(videoFiles.length,8);i++) usableBeats.push(i*step);
        log('no detected beats — using fallback timings');
      }

      // for each beat, pick a clip and trim a short segment (0.8 to 1.6s) to place there
      const segs = [];
      for(let i=0;i<usableBeats.length && i<videoFiles.length;i++){
        const start = Math.max(0, usableBeats[i]);
        const dur = Math.min(1.2, targetLen - (usableBeats[i] || 0));
        const inName = `clip${i}.mp4`;
        const outName = `seg${i}.mp4`;
        // ffmpeg trim: take first dur seconds — no seek for simplicity
        const cmd = ['-i', inName, '-t', `${dur}`, '-c', 'copy', outName];
        log('running ffmpeg for segment', outName);
        try{ await ffmpeg.run(...cmd); }catch(e){ log('segment failed', e.message) }
        segs.push(outName);
      }

      // concatenate segments
      // build concat list file
      let concatTxt = segs.map(s=>`file '${s}'`).join('\n');
      ffmpeg.FS('writeFile','concat.txt', concatTxt);
      const final = 'out.mp4';
      log('concatenating', segs.length, 'segments');
      try{
        await ffmpeg.run('-f','concat','-safe','0','-i','concat.txt','-c','copy', final);
        log('concatenation done');
      }catch(e){
        log('concat failed — will try re-encode concat fallback');
        try{
          await ffmpeg.run('-f','concat','-safe','0','-i','concat.txt','-c:v','libx264','-preset','fast','-crf','23', final);
          log('fallback concat succeeded');
        }catch(err){ log('fallback concat failed', err.message) }
      }

      // read file and generate blob URL
      const data = ffmpeg.FS('readFile', final);
      const videoBlob = new Blob([data.buffer], { type: 'video/mp4' });
      const url = URL.createObjectURL(videoBlob);
      const a = document.createElement('a'); 
      a.href = url; 
      a.download = 'short.mp4'; 
      a.textContent = 'Download Generated Short'; 
      a.style.display='block';
      log('Done — your video is ready. Click link to download.');
      log('If the link does not appear, check console for errors.');
      const downloadEl = document.createElement('div'); 
      downloadEl.appendChild(a);
      document.body.appendChild(downloadEl);
    }

    generateAllBtn.addEventListener('click', async ()=>{
      generateAllBtn.disabled = true; 
      log('starting analysis and generation...');
      beatsEl.textContent = '(working...)';
      try {
        await analyzeAudio(audioFile);
        await generate();
      } catch(e) {
        log('generation failed:', e.message);
      }
      generateAllBtn.disabled = false;
    });

  </script>
</body>
</html>
